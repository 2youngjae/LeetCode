class Solution {
public:
    struct Node {
	int val;
	int idx;
	Node(){}
	Node(int val, int idx) :val(val), idx(idx) {}
};

struct CompareFromLeftToRight {
	int operator()(const Node& n1, const Node& n2) {
		if (n1.val == n2.val) {
			return n1.idx < n2.idx;
		}
		return n1.val < n2.val;
	}
};

struct CompareFromRightToLeft {
	int operator()(const Node& n1, const Node& n2) {
		if (n1.val == n2.val) {
			return n1.idx > n2.idx;
		}
		return n1.val < n2.val;
	}
};

priority_queue<Node, vector<Node>, CompareFromLeftToRight> lrpq;
priority_queue<Node, vector<Node>, CompareFromRightToLeft> rlpq;
int answer = 0;
int d[30000];

void goLeft(vector<int>& height, int pivot_idx) {
	if (pivot_idx <= 0) return;

	//printf("goLeft(), pivot_val = %d, pivot_idx = %d\n", height[pivot_idx], pivot_idx);

	Node node;
	while (true) {
		if (lrpq.empty()) {
			return;
		}

		node = lrpq.top();
		lrpq.pop();

		if (node.idx < pivot_idx) {
			answer += ((min(height[node.idx], height[pivot_idx])) * (pivot_idx - node.idx - 1)) - (d[pivot_idx - 1] - d[node.idx]);
			break;
		}
	}
	goLeft(height, node.idx);
}

void goRight(vector<int>& height, int pivot_idx) {
	if (pivot_idx >= height.size() - 1) return;

	//printf("goRight(), pivot_val = %d, pivot_idx = %d\n", height[pivot_idx], pivot_idx);

	Node node;
	while (true) {
		if (rlpq.empty()) {
			return;
		}

		node = rlpq.top();
		rlpq.pop();

		if (node.idx > pivot_idx) {
			answer += ((min(height[node.idx], height[pivot_idx])) * (node.idx - pivot_idx - 1)) - (d[node.idx - 1] - d[pivot_idx]);
			break;
		}
	}
	goRight(height, node.idx);
}

int trap(vector<int>& height) {
	int pivot = 0;
	int pivot_idx = 0;

	for (int i = 0; i < height.size(); i++) {
		if (i == 0) {
			d[i] = height[i];
		}
		else {
			d[i] = d[i - 1] + height[i];
		}
		lrpq.push(Node(height[i], i));
		rlpq.push(Node(height[i], i));
		if (pivot < height[i]) {
			pivot = height[i];
			pivot_idx = i;
		}
	}

	goLeft(height, pivot_idx);
	goRight(height, pivot_idx);

	//while (!lrpq.empty()) {
	//	Node node = lrpq.top();
	//	lrpq.pop();
	//	printf("%d %d\n", node.val, node.idx);
	//}

	return answer;
}
};
